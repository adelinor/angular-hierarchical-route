{"name":"angular-hierarchical-route","tagline":"Helps the definition and usage of routes in an AngularJS app","body":"This is an illustrated introduction to the `angular-hierarchical-route` module which purpose is to help you build and use routes in your AngularJS app.\r\nThe [README file](https://github.com/adelinor/angular-hierarchical-route/blob/master/README.md) provides a more succinct version of this content.\r\n\r\n![introduction with controller](content_img/intro_with_ctrl.png)\r\n\r\n### [1] Building routes\r\nBefore the app starts offering its services to the users, the route gets assembled ...\r\n\r\n![route construction](content_img/route_construction.png)\r\n\r\n... with the `$routeProvider` of `ngRoute` when configuring your application AngularJS module:\r\n\r\n```js\r\nangular.module('sample.routes', ['ngRoute'])\r\n.config(['$routeProvider', function($routeProvider) {\r\n\r\n    $routeProvider.when('/home', {templateUrl: 'home/home.html',\r\n                                  controller: 'HomeCtrl'});\r\n    // ...\r\n}]);\r\n```\r\n\r\nWhen you want to associate **several routes to a view** (displayed with the `ng-view` directive), you can use this module to create a hierarchical route. A **hierarchical route** functions like an **underground line**:\r\n\r\n![underground line](content_img/underground_line.png)\r\n\r\nIt has places where you can join and stop: similar to the **stations** of an underground line.\r\nThis metaphor also applies to the relationship between a *hierarchical route* and a *route*: a route\r\nbelongs to a hierarchical route in the same way as a station belongs to an underground line.\r\n\r\n### [2] Defining hierarchical routes\r\nTo define a hierarchical route, you need to inject the `hierarchyProvider` in the config method of your module:\r\n\r\n```js\r\nangular.module('sample.routes', ['ngRoute', 'angularHierarchicalRoute'])\r\n.config(['$routeProvider', 'hierarchyProvider',\r\n         function($routeProvider, hierarchyProvider) {\r\n\t\r\n    hierarchyProvider.add({\r\n        rootPath: '/home',\r\n        templateUrl: 'home/home.html',\r\n        controller: 'HomeCtrl'})\r\n    .callableFrom('/home','home')\r\n    .callableFrom('/home/:countryId','choose city')\r\n    // ... \r\n    .registerWith($routeProvider);\r\n```\r\nAll routes in the hierarchy share the same view and controller. The `rootPath` must be one of the routes in your hierarchy and is the default entry point to your view.\r\nFinally you register your hierarchical route with `$routeProvider` .\r\n\r\n![station called 'choose city'](content_img/station.png)\r\n\r\nThe code extracts are taken from a sample application, [see live demo](http://adelinor.github.io/angular-hierarchical-route/sample/with-helper). The source code is under\r\n[/sample/with-helper/](https://github.com/adelinor/angular-hierarchical-route/tree/master/sample/with-helper)\r\non [GitHub](https://github.com/adelinor/angular-hierarchical-route).\r\n\r\nWhen all your routes are created, your application can start receiving users.\r\n\r\n![users on your route](content_img/users_en_route.png)\r\n\r\n### [3] Users on your route\r\nUsers (the vehicle on the photo) will be taking the routes defined in your app. When the route they are on corresponds to a `callable` route (a station), the **controller** will be provided with a resolved object:\r\n\r\n```js\r\n.controller('HomeCtrl', ['$scope', 'resolved',\r\n                         function($scope, resolved) {\r\n    //Set loaded data in scope\r\n    $scope.countries = resolved.countries;\r\n    $scope.cities = resolved.cities;\r\n\r\n    //...\r\n}])\r\n```\r\n\r\nThis object is a map of the data to resolve.\r\n\r\n![Controller receives resolved](content_img/ctrl_resolved.png)\r\n\r\nThe data to resolve is defined when creating the callable route:\r\n![What's in resolved?](content_img/resolved_open.png)\r\n\r\n```js\r\n.callableFrom('/home/:countryId','choose city')\r\n    .resolve({\r\n        countries: annotatedFnCountries,\r\n        cities: annotatedFnCities\r\n    })\r\n```\r\n\r\nwhere `annotatedFnCountries` and `annotatedFnCities` are functions returning promises with annotations to inject dependencies:\r\n\r\n```js\r\nvar annotatedFnCountries = ['adminService',\r\n    function(adminService) {\r\n        return adminService.countries();\r\n    }];\r\n\r\nvar annotatedFnCities = ['adminService', '$route',\r\n    function(adminService, $route) {\r\n        return adminService.citiesForCountry($route.current.params.countryId);\r\n    }];\r\n```\r\n\r\n### [4] Route guidance\r\nThe **controller** also gets provided a `routeCalled` object which acts as a guidance leaflet to:\r\n\r\n* know where you are\r\n* access ngRoute's services: `$route`, `$location` and `$routeParams`\r\n* navigate to other stations in the line\r\n\r\n![routeCalled to controller](content_img/ctrl_route_called.png)\r\n\r\n\r\n### [5] View constants\r\nSimilar to the promises to resolve, your can define constants that will be passed to the **controller** when a user is at your station.\r\n\r\nFor example:\r\n```js\r\n.callableFrom('/home/:countryId/:cityId','current')\r\n    .constants({weatherView: 'home/current-weather.html'})\r\n```\r\n\r\nis made available to the controller under the name `constants`:\r\n\r\n```js\r\n.controller('HomeCtrl', ['$scope', 'constants',\r\n                         function($scope, constants) {\r\n    //...\r\n    $scope.weatherView = constants.weatherView;\r\n    //...\r\n}])\r\n```\r\n\r\nThis mechanism allows to include sub-views with the directive `ng-include='*constant*'`. This reduces the number of elements in your view that are shown or hidden: `ng-show=*toggle*`, which as a consequence makes your view more readable.\r\n\r\nFor instance, what would be in one view as:\r\n```html\r\n<div class=\"col-xs-6\" ng-show=\"cityId && (! forecastMode)\">\r\n    <!-- view content ...-->\r\n</div>\r\n<div class=\"col-xs-6\" ng-show=\"cityId && forecastMode\">\r\n    <!-- view content ...-->\r\n</div>\t\r\n```\r\n\r\ncan now be written as:\r\n\r\n```html\r\n<div class=\"col-xs-6\" ng-show=\"cityId\" ng-include=\"weatherView\">\r\n``` \r\n\r\n### [6] Navigation\r\n\r\n**Go to by name**\r\n\r\nThis is about going to a station in an underground line by knowing the station name. You invoke the routeCalled.goTo function:\r\n\r\n```js\r\nrouteCalled.goTo('choose city', params);\r\n```\r\n\r\n**Go to by parameter signature**\r\n\r\nAs well as you could describe an underground station by its characteristics: \"a station with green walls and yellow ceiling\", here you identify a station by the keys that are used in the route definition. For instance:\r\n\r\n```js\r\nrouteCalled.goToFirstWith({countryId: value});\r\n```\r\n\r\nwould stop at the first callable route within this hierarchical route which has `:countryId` as a key in the route and nothing else.\r\n\r\n\r\n**Update current parameters or go to by parameter signature**\r\n\r\nIf the user updates the content an existing route parameter, the `routeCalled.updateOrGoToFirstWith` function will stay on the same view but updated parameters.\r\n\r\nWhen new parameter is added, the `routeCalled.updateOrGoToFirstWith` function will search for a callable for this new set of parameter keys. In this case this works as the routeCalled.goToFirstWith function.\r\n\r\n```js\r\nrouteCalled.updateOrGoToFirstWith({countryId: value, cityId: newValue});\r\n```\r\n\r\n![Thank you and bye](content_img/thankyoubye.png)\r\n\r\nThank your for your attention.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}